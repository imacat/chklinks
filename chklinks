#! /usr/bin/perl -w
# chklinks: A non-threaded Perl link checker

# Copyright (c) 2003-2007 imacat.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# First written: 2003-04-12

package main;
use 5.006;
use strict;
use warnings;
use File::Basename qw(basename);
use Getopt::Long qw(GetOptions);
use HTTP::Cookies qw();
use LWP::RobotUA qw();
use Sys::Hostname qw(hostname);
# Prototype declaration
sub main();
sub parse_args();
sub check_links($);

our ($THIS_FILE, $VERBOSE);
use vars qw($VERSION);
$THIS_FILE = basename($0);
$VERSION = "3.9901";
$VERBOSE = 1;

our (%CONF, $UA, %URIS, $LOCAL_TARGET);
use vars qw(@STARTS);
%CONF = qw();
$CONF{"EXCLUDES"} = [];
$UA = new LWP::RobotUA(
    "agent"         => "$THIS_FILE-robot/$VERSION (using "
                        . (LWP::RobotUA->can("_agent")?
                            LWP::RobotUA->_agent:
                            "libwww-perl/" . $LWP::VERSION)
                        . ")",
    "from"          => (getlogin or getpwuid $> or $> or $THIS_FILE)
                        . "@" . hostname,
    "keep_alive"    => 1,
    "cookie_jar"    => new HTTP::Cookies,
);
%URIS = qw();
undef $LOCAL_TARGET;
@STARTS = qw();
use constant DEFAULT_RECURSIVE => 1;
use constant DEFAULT_PARENT => 0;
use constant DEFAULT_NOREMOTE => 0;

use vars qw($VERMSG $SHORTHELP $HELPMSG);
$VERMSG = "$THIS_FILE v$VERSION by imacat <imacat\@mail.imacat.idv.tw>";
$SHORTHELP = "Try `$THIS_FILE --help' for more information.";
$HELPMSG = << "EOT";
Usage: $THIS_FILE [options] url1 [url2 [url3 ...]]
Check links on the specific website.

  -1,--onelevel      Check the links on this page and stops.
  -r,--recursive     Recursively check through this site. (default)
  -b,--below         Only check the links below this directory. (default)
  -p,--parent        Trace back to the parent directories.
  -l,--local         Only check the links on this same host.
  -s,--span          Check the links to other hosts (without recursion).
                     (default)
  -e,--exclude path  Exclude this path.  Check for their existence but not
                     check the links on them, just like they are on a foreign
                     site.  Multiple --exclude are OK.
  -i,--include path  Include this path.  An opposite of --exclude that cancels
                     its effect.  The latter specified has a higher priority.
  -d,--debug         Display debug messages.  Multiple --debug to debug more.
  -q,--quiet         Disable debug messages.  An opposite that cancels the
                     effect of --debug.
  -h,--help          Display this help.
  -v,--version       Display version number.
  url1,url2...       The URLs of the websites to check against.

EOT

main;
exit 0;

# main: Main program
sub main() {
    local ($_, %_);
    
    # Parse the arguments
    parse_args;
    
    $_ = new URI("/home/imacat/tmp");
    print "scheme: ".(defined $_->scheme? "\"".$_->scheme."\"": "(undef)")."\n";
    #print "host: ".(defined $_->host? "\"".$_->host."\"": "(undef)")."\n";
    
    $_ = new URI("http://www.imacat.idv.tw/tech/reslog.html");
    print "scheme: ".(defined $_->scheme? "\"".$_->scheme."\"": "(undef)")."\n";
    print "host: ".(defined $_->host? "\"".$_->host."\"": "(undef)")."\n";
    
    $_ = new URI("http:///tech/reslog.html");
    print "scheme: ".(defined $_->scheme? "\"".$_->scheme."\"": "(undef)")."\n";
    print "host: ".(defined $_->host? "\"".$_->host."\"": "(undef)")."\n";
    
    print _private::URI->is_abs(new URI("/home/imacat/tmp"))."\n";
    print _private::URI->is_abs(new URI("http://www.imacat.idv.tw/tech/reslog.html"))."\n";
    print _private::URI->is_abs(new URI("http:///tech/reslog.html"))."\n";
    
    $_ = "\\\\Rinse\\imacat\\tmp";
    chdir $_                            or die "$THIS_FILE: $_: $!";
    
    # Check each URL
    check_links $_ foreach @STARTS;
    
    print STDERR "Done.  " . (time - $^T) . " seconds elapsed.\n"
        if $VERBOSE > 0;
    return;
}

# parse_args: Parse the arguments
sub parse_args() {
    local ($_, %_);
    
    # Get the arguments
    eval {
        local $SIG{"__WARN__"} = sub { die $_[0]; };
        Getopt::Long::Configure(qw(no_auto_abbrev bundling));
        GetOptions( "onelevel|1"=>sub { $CONF{"RECURSIVE"} = 0; },
                    "recursive|r"=>sub { $CONF{"RECURSIVE"} = 1; },
                    "below|b"=>sub { $CONF{"PARENT"} = 0; },
                    "parent|p"=>sub { $CONF{"PARENT"} = 1; },
                    "local|l"=>sub { $CONF{"NOREMOTE"} = 1; },
                    "span|s"=>sub { $CONF{"NOREMOTE"} = 0; },
                    "exclude|e=s"=>sub { unshift @{$CONF{"EXCLUDES"}}, "-" . $_[1]; },
                    "include|i=s"=>sub { unshift @{$CONF{"EXCLUDES"}}, "+" . $_[1]; },
                    "debug|d+"=>\$VERBOSE,
                    "quiet|q"=>sub { $VERBOSE-- if $VERBOSE > 0; },
                    "help|h"=>sub { print $HELPMSG; exit 0; },
                    "version|v"=>sub { print "$VERMSG\n"; exit 0; });
    };
    die "$THIS_FILE: $@$SHORTHELP\n" if $@ ne "";
    
    # Show progress
    $| = 1 if $VERBOSE > 2;
    
    # Check the arguments
    # Arguments are URLs
    @STARTS = qw();
    while (@ARGV > 0) {
        $_ = shift @ARGV;
        push @STARTS, $_;
    }
    die "$THIS_FILE: Please specify the URL to check\n$SHORTHELP\n"
        if @STARTS == 0;
    
    # Default values
    $CONF{"RECURSIVE"} = DEFAULT_RECURSIVE if !exists $CONF{"RECURSIVE"};
    $CONF{"PARENT"} = DEFAULT_PARENT if !exists $CONF{"PARENT"};
    $CONF{"NOREMOTE"} = DEFAULT_NOREMOTE if !exists $CONF{"NOREMOTE"};
    
    return;
}

# check_links: Check links from a URL
sub check_links($) {
    local ($_, %_);
    my ($start, $uri);
    $start = $_[0];
    
    # Try to initialize it
    return if !defined($uri = new _private::URI($start));
    # Save our target
    $LOCAL_TARGET = $uri->target;
    
    print "\"".$uri->as_string."\"\n" if defined $uri;
    
    return;
}


# _private::URI: A URI handler
package _private::URI;
use 5.006;
use strict;
use warnings;

use Cwd qw(cwd);
use File::Spec qw();
use URI qw();

use vars qw($CWD);
BEGIN {
undef $CWD;
}

# new: Initialize the URI handler
sub new : method {
    local ($_, %_);
    my ($class, $self, $uri, $refuri, $redir, $baseuri, $is_abs);
    ($class, $uri, $refuri, $redir) = @_;
    
    # The base URI
    $refuri = new _private::URI($refuri)
        if  defined $refuri
            && (ref $refuri eq "" || ref($refuri) =~ /^URI\b/);
    $redir = new _private::URI($redir)
        if  defined $redir
            && (ref $redir eq "" || ref($redir) =~ /^URI\b/);
    $baseuri = defined $redir? $redir:
        defined $refuri? $refuri: $class->new_cwd;
    
    # The start URL
    undef $is_abs;
    if (!defined $refuri) {
        # A scalar URI
        if (ref $uri eq "") {
            # URIs that looks like having a scheme
            if ($uri =~ /^[^a-z][a-z0-9\+\-\.]+:/i) {
                $uri = new URI($uri);
            # UNC paths on MS-Windows, OS/2, DOS, NetWare or Cygwin
            } elsif (   $^O =~ /^(?:MSWin32|os2|dos|NetWare|cygwin)$/
                        && ($uri =~ /^\/\/([^\/]+)\/([^\/]+.*)$/
                            || $uri =~ /^\\\\([^\\]+)\\([^\\]+.*)$/)) {
                $uri =~ s/\\/\//g;
                $uri = new URI("file:$uri");
                $is_abs = 0;
            # Paths on MS-Windows that have a drive letter
            } elsif ($^O eq "MSWin32" && $uri =~ /^([a-z]:)(.*)$/i) {
                my ($drive, $path, $dcwdpath);
                ($drive, $path) = (uc $1, $2);
                $path =~ s/\\/\//g;
                # Not absolute
                if ($path !~ /^\//) {
                    # No such drive
                    die "$THIS_FILE: $drive: No such drive\n"
                        if !defined($_ = Cwd::getdcwd($drive));
                    /^[a-z]:(.*)$/i;
                    $dcwdpath = $1;
                    $dcwdpath =~ s/\\/\//g;
                    $dcwdpath =~ s/(?<!\/)$/\//;
                    $path = new URI($path);
                    $dcwdpath = new URI($dcwdpath);
                    $path = $path->abs($dcwdpath)->canonical->as_string;
                }
                $uri = new URI("file://localhost/$drive$path");
                $is_abs = 0;
            # Paths on Cygwin starting with root are always local
            } elsif ($^O eq "cygwin" && $uri =~ /^[\/]/) {
                $uri =~ s/\\/\//g;
                $uri = new URI("file://localhost$uri");
                $is_abs = 0;
            # Else - As a native file system path
            } else {
                my (@paths, @dirs, $path);
                @paths = File::Spec->splitpath($uri);
                @dirs = File::Spec->splitdir($paths[1]);
                @dirs = map $_ eq File::Spec->updir? "..":
                    $_ eq File::Spec->curdir? ".": $_, @dirs;
                pop @dirs if $dirs[$#dirs] eq "";
                $path = $paths[0] . join("/", @dirs) . "/" . $paths[2];
                $uri = new URI($path);
                $is_abs = 0;
            }
        }
    }
    # Convert into an URI object if URI is provided as text
    $uri = new URI($uri) if ref $uri eq "";
    # Decided if the URI is absolute
    if (!defined $is_abs) {
        if (!defined $uri->scheme) {
            $is_abs = 0;
        } else {
            $_ = "_private::URI::" . lc $uri->scheme;
            $is_abs = $_->is_abs($uri);
        }
    }
    
    # Make the URI absolute
    $uri = $uri->abs($baseuri->{"uri"})
        if  !defined $uri->scheme
            || $uri->scheme eq $baseuri->{"uri"}->scheme;
    # Remove the fragment
    $uri->fragment(undef);
    # Use its canonical form
    $uri = $uri->canonical;
    
    # This URI was found before
    if (exists $URIS{$uri->as_string}) {
        $self = $URIS{$uri->as_string};
        # Add this referer
        push @{$self->{"refs"}}, $refuri
            if  defined $refuri
                && grep($_->eq($refuri->{"uri"}), @{$self->{"refs"}}) == 0;
        return $self;
    }
    
    # Find the scheme-specific subclass
    $class = "_private::URI::" . lc $uri->scheme;
    # Initialize the handler
    $self = bless {}, $class;
    $self->{"uri"} = $uri;
    $self->{"is_abs"} = $is_abs;
    $self->{"refs"} = [];
    push @{$self->{"refs"}}, $refuri if defined $refuri;
    $self->{"checked"} = undef;
    $self->{"links"} = [];
    $self->{"redir"} = undef;
    # Unsupported scheme
    if ($uri->scheme !~ /^(?:http|https|ftp|gopher|file|mailto)$/i) {
        warn $self->label . ": Skipping unsupported " . $uri->scheme . " scheme\n";
        return undef;
    }
    return undef if !$self->scheme_init_ok;
    return $self;
}

# new_cwd: Initialize the URI handler of the current working directory
sub new_cwd : method {
    local ($_, %_);
    my ($path, @paths, @dirs, $host, $uri);
    
    # Already initialized
    return $CWD if defined $CWD;
    
    # Create the URI of the current working directory
    @paths = File::Spec->splitpath(cwd);
    # Convert the path to the UNIX format
    @dirs = File::Spec->splitdir($paths[1]);
    pop @dirs if $dirs[$#dirs] eq "";
    push @dirs, $paths[2] if $paths[2] ne "";
    push @dirs, "" if $dirs[$#dirs] ne "";
    unshift @dirs, "" if $dirs[0] ne "";
    $paths[1] = join "/", @dirs;
    # Deal with the UNC volume name
    $host = "localhost";
    if ($^O =~ /^(?:MSWin32|os2|dos|NetWare)$/) {
        # UNC path
        if (    $paths[0] =~ /^\/\/([^\/]+)\/([^\/]+)$/
                || $paths[0] =~ /^\\\\([^\\]+)\\([^\\]+)$/) {
            $host = $1;
            $paths[0] = "/$2";
        }
    } elsif ($^O eq "cygwin") {
        # UNC path
        $host = $1
            if  $paths[1] =~ s/^\/\/([^\/]+)(\/[^\/]+)/$2/
                || $paths[1] =~ s/^\\\\([^\\]+)(\\[^\\]+)/$2/;
    }
    $path = join "", @paths;
    $path =~ s/^(?!\/)/\//;
    
    $uri = new URI;
    $uri->scheme("file");
    $uri->host($host);
    $uri->path($path);
    $uri = $uri->canonical;
    
    # Initialize the handler
    $CWD = bless {}, "_private::URI::file";
    $CWD->{"uri"} = $uri;
    $CWD->{"refs"} = [];
    $CWD->{"checked"} = undef;
    $CWD->{"links"} = [];
    $CWD->{"redir"} = undef;
    
    # This is always OK.  No need to check with scheme_init_ok()
    return $CWD;
}

# scheme_init_ok: Try to initialize this scheme and return if it succeed
#   Default to be OK.  Override this method to add checks.
sub scheme_init_ok : method { 1; }

# check: Check the URI
sub check : method {
    local ($_, %_);
    my ($self, $uri, $r, $doc, @links);
    $self = $_[0];
    # Checked before
    return @{$self->{"checked"}} if $self->{"checked"};
    
    # Request the URI
    $uri = $self->{"uri"};
    $r = $self->request;
    
    # Only 200 is OK
    if ($r->code != 200) {
        # 204 No Content
        if ($r->code == 204) {
            $self->{"checked"} = [1, qw()];
            return @{$self->{"checked"}};
        
        # 3XX Redirect
        } elsif (grep($r->code == $_, (301, 302, 303, 307)) > 0) {
            my ($is_full_uri, $ruri, $rtarget);
            # Redirect without location is an error
            if (!defined $r->header("Location")) {
                $self->outfail($r->status_line . ": Redirect without location");
                $self->{"checked"} = [0, qw()];
                return @{$self->{"checked"}};
            }
            
            $ruri = new URI($r->header("Location"));
            
            # Deal with non-canonical location
            $is_full_uri = 1;
            # Non-absolute location should be warned
            if (!defined $ruri->scheme) {
                $is_full_uri = 0;
                $ruri->scheme($uri->scheme);
            }
            # Skip schemes that are not supported
            #return (undef, undef) if !exists $ALLOWED_SCHEMES{$uri->scheme};
            if (!defined $ruri->host || $ruri->host eq "") {
                $is_full_uri = 0;
                $ruri->host($uri->host);
            }
            if ($ruri->path eq "") {
                $is_full_uri = 0;
                $ruri->path("/");
            }
            warn "$THIS_FILE: WARNING: " . $self->as_string . ": " . $r->status_line . ": "
                    . "Location not canonical: " . $r->header("Location") . "\n"
                if !$is_full_uri && $VERBOSE > 1;
            $ruri->fragment(undef);
            # Use its canonical form
            $ruri = $ruri->canonical;
            
            # Save it
            $URIS{$ruri->as_string} = $ruri if !exists $URIS{$ruri->as_string};
            
            # 301 Moved Permanently should be treated as an error, because we need
            #   to change the reference from now on.
            if ($r->code == 301) {
                $self->outfail($r->status_line . ": " . $ruri->as_string);
                return (undef, $ruri->as_string);
            }
            
            # Warn when not quiet
            print $self->label . " " . $r->status_line . ": " . $ruri->as_string . "\n"
                    if $VERBOSE > 1;
            return (undef, $ruri->as_string);
        
        # Bad response that we cannot go on
        } elsif (grep($r->code == $_, (400, 403, 404, 410, 500)) > 0) {
            $self->outfail($r->status_line);
            $self->{"checked"} = [0, qw()];
            return @{$self->{"checked"}};
        
        # Bad response that we should not keep requesting on a same server
        } elsif ($r->code == 503) {
            $self->outfail($r->status_line);
            #$NOREQ_HOSTS{noreq_key $self->as_string} = $self->as_string;
            $self->{"checked"} = [0, qw()];
            return @{$self->{"checked"}};
        
        # Unable to process
        } else {
            # Unable to process
            $self->outfail($r->status_line . ": Unable to process this response");
            $self->{"checked"} = [0, qw()];
            return @{$self->{"checked"}};
        }
    }
    
    # 200 OK
    # Only return the body if text/html
    # Fix the content type of XHTML in file URI
    if ($uri->scheme eq "file" && $uri->as_string =~ /\.xhtml$/) {
        $_ = "application/xhtml+xml";
    # Parse the content type -- keep the last one when multiple
    } else {
        @_ = split /,\s*/, $r->header("Content-Type");
        $_ = $_[$#_];
    }
    return ($r->content, undef)
        if /^text\/html\b/ || /^application\/xhtml\+xml\b/;
    return (undef, undef);
    
    $self->{"checked"} = [1, @links];
    return @{$self->{"checked"}};
}

# request: Send a request to the URI and return the response
#   Default to the simple form using URI
sub request : method {
    $UA->get($_[0]->as_string);
}

# as_string: Print the URI
sub as_string : method {
    return exists $_[0]->{"uri"}? $_[0]->{"uri"}->as_string: "";
}

# label: The label to print when error, usually URI plus referers.
sub label : method {
    local ($_, %_);
    my ($self, @refuris);
    $self = $_[0];
    # There is no referer
    return $self->as_string if @{$self->{"refs"}} == 0;
    # There are referers
    @_ = @{$self->{"refs"}};
    @_ = map join(" => ", @$_), @_;
    return sprintf "%s (Referer: %s)", $self->as_string,
        join(", ", @_);
}

# outfail: Print a failure
sub outfail : method {
    local ($_, %_);
    my ($self, $level, $message);
    ($self, $level, $message) = @_;
    print $self->label;
    # Do not output message when quiet
    print ": $message" if $VERBOSE > 0;
    print "\n";
    return;
}

# target: The target of the URI
sub target : method {
    local ($_, %_);
    my ($self, $uri, $target);
    $self = $_[0];
    # Obtained before
    return $self->{"target"} if exists $self->{"target"};
    $uri = $self->{"uri"};
    $target = new URI;
    $target->scheme($uri->scheme);
    $target->host($uri->host);
    $target->port($uri->port) if $uri->can("port") && defined $uri->port;
    return ($self->{"target"} = $target->canonical);
}

# is_abs: If a given URI is absolute
#   This is a static method.
sub is_abs : method {
    local ($_, %_);
    $_ = $_[1];
    return 0
        unless $_->can("host")
                && defined $_->host
                && $_->host ne "";
    return 1;
}


# _private::URI::http: An HTTP URI handler
package _private::URI::http;
use 5.008;
use strict;
use warnings;
use base qw(_private::URI);

use HTTP::Request qw();

use vars qw(%NOREQ_HOSTS);
BEGIN {
%NOREQ_HOSTS = qw();
}

# request: Send a request to the URI and return the response
sub request : method {
    local ($_, %_);
    my ($self, $r, $request, $w, $sigwarn);
    $self = $_[0];
    $request = new HTTP::Request(GET => $self->as_string);
    # Set the referer
    $request->header("Referer", ${${$self->{"refs"}}[0]}[0]->as_string);
    # Gracefully deal with robots.txt warnings
    $sigwarn = $SIG{"__WARN__"};
    undef $w;
    local $SIG{"__WARN__"} = sub { $w = $_[0]; };
    $r = $UA->simple_request($request);
    $SIG{"__WARN__"} = $sigwarn;
    if (defined $w) {
        # Malformed robots.txt warnings
        if ($w =~ /^RobotRules <[^\n]+>: Unexpected line: /) {
            # Skip malformed robots.txt warnings on remote sites
            # We are assumed to have no control on the remote sites
            if ($self->{"uri"}->host ne $LOCAL_TARGET) {
            
            # Skip warnings about Crawl-delay:
            # As of writing this, WWW::RobotRules 1.33 in libwww-perl 5.805
            #   does not recognized the Crawl-delay: rule yet.
            } elsif ($w =~ /^RobotRules <[^\n]+>: Unexpected line: Crawl-delay:/i) {
            
            # Warn on malformed lines in our local robots.txt
            } else {
                warn $self->label . ": $w";
            }
        
        # Other warnings
        } else {
            warn $self->label . ": $w";
        }
    }
    return $r;
}


# _private::URI::https: An HTTPS URI handler
package _private::URI::https;
use 5.008;
use strict;
use warnings;
use base qw(_private::URI::http);

use vars qw($HAS_CRYPT_SSLEAY);
BEGIN {
undef $HAS_CRYPT_SSLEAY;
}

# scheme_init_ok: Try to initialize this scheme and return if it succeed
sub scheme_init_ok : method {
    local ($_, %_);
    my ($self, $uri);
    $self = $_[0];
    $uri = $self->{"uri"};
    # Try to find Crypt::SSLeay
    $HAS_CRYPT_SSLEAY = eval "use Crypt::SSLeay qw(); 1;"? 1: 0
        if !defined $HAS_CRYPT_SSLEAY;
    if (!$HAS_CRYPT_SSLEAY) {
        warn $self->label . ": Crypt::SSLeay not found, skipping unsupported https scheme.\n";
        return undef;
    }
    # OK
    return 1;
}


# _private::URI::ftp: An FTP URI handler
package _private::URI::ftp;
use 5.008;
use strict;
use warnings;
use base qw(_private::URI);


# _private::URI::gopher: A gopher URI handler
package _private::URI::gopher;
use 5.008;
use strict;
use warnings;
use base qw(_private::URI);


# _private::URI::file: A file URI handler
package _private::URI::file;
use 5.008;
use strict;
use warnings;
use base qw(_private::URI);

use File::Spec qw();

# scheme_init_ok: Try to initialize this scheme and return if it succeed
sub scheme_init_ok : method {
    local ($_, %_);
    my ($self, $uri);
    $self = $_[0];
    $uri = $self->{"uri"};
    # file URI not on localhost is not good
    if (    defined $uri->host
            && $uri->host ne ""
            && $uri->host ne "localhost"
            && $uri->host ne $self->new_cwd->{"uri"}->host) {
        warn $self->label . ": Skipping file URI that is not local.\n";
        return undef;
    }
    # OK
    return 1;
}

# as_string: Print the URI
sub as_string : method {
    local ($_, %_);
    my ($self, $uri, @paths, @dirs, $path);
    $self = $_[0];
    $uri = $self->{"uri"};
    # Windows, DOS and alike - Return volume or UNC path
    if ($^O =~ /^(?:MSWin32|os2|dos|NetWare)$/) {
        # Local path
        if (    !defined $uri->host
                || $uri->host eq ""
                || $uri->host eq "localhost") {
            @dirs = split /\//, $uri->path;
            push @dirs, "" if $uri->path =~ /\/$/ && $dirs[$#dirs] ne "";
            shift @dirs if $dirs[0] eq "";
            @paths = ("", "", "");
            $paths[0] = $dirs[0];
            $dirs[0] = "";
            $paths[2] = pop @dirs;
            $paths[1] = File::Spec->catdir(@dirs);
            $paths[1] .= "\\" if $uri->path =~ /\/$/ && $paths[1] !~ /\/$/;
            return File::Spec->catpath(@paths);
        # UNC path
        } else {
            @dirs = split /\//, $uri->path;
            push @dirs, "" if $uri->path =~ /\/$/ && $dirs[$#dirs] ne "";
            shift @dirs if $dirs[0] eq "";
            @paths = ("", "", "");
            $paths[0] = sprintf "\\\\%s\\%s", $uri->host, $dirs[0];
            $dirs[0] = "";
            $paths[2] = pop @dirs;
            $paths[1] = File::Spec->catdir(@dirs);
            $paths[1] .= "\\" if $uri->path =~ /\/$/ && $paths[1] !~ /\/$/;
            return File::Spec->catpath(@paths);
        }
    # Cygwin - Return UNC path with forward slashes
    } elsif ($^O eq "cygwin") {
        # Local path
        if (    !defined $uri->host
                || $uri->host eq ""
                || $uri->host eq "localhost") {
            return $uri->path;
        # UNC path
        } else {
            @dirs = split /\//, $uri->path;
            push @dirs, "" if $uri->path =~ /\/$/ && $dirs[$#dirs] ne "";
            shift @dirs if $dirs[0] eq "";
            @paths = ("", "", "");
            $paths[0] = sprintf "//%s/%s", $uri->host, $dirs[0];
            $dirs[0] = "";
            $paths[2] = $dirs[$#dirs];
            $dirs[$#dirs] = "";
            $paths[1] = join "/", @dirs;
            return join "", @paths;
        }
    # Others - Return with local file system format
    } else {
        @dirs = split /\//, $uri->path;
        
        return $uri->path;
    }
}

# is_abs: If a given URI is absolute
#   This is a static method.
#   file URI are always absolute when scheme is determined
sub is_abs : method { 1; }


# _private::URI::mailto: A mailto URI handler
package _private::URI::mailto;
use 5.008;
use strict;
use warnings;
use base qw(_private::URI);

use vars qw($HAS_NET_DNS);
BEGIN {
undef $HAS_NET_DNS;
}

# scheme_init_ok: Try to initialize this scheme and return if it succeed
sub scheme_init_ok : method {
    local ($_, %_);
    my ($self, $uri);
    $self = $_[0];
    $uri = $self->{"uri"};
    # Try to find Crypt::SSLeay
    $HAS_NET_DNS = eval "use Net::DNS qw(); 1;"? 1: 0
        if !defined $HAS_NET_DNS;
    if (!$HAS_NET_DNS) {
        warn $self->label . ": Net::DNS not found, skipping unsupported mailto scheme.\n";
        return undef;
    }
    # OK
    return 1;
}

# target: The target of the URI
sub target : method {
    local ($_, %_);
    my ($self, $uri, $target);
    $self = $_[0];
    # Obtained before
    return $self->{"target"} if exists $self->{"target"};
    $uri = $self->{"uri"};
    $target = new URI;
    $target->scheme($uri->scheme);
    $target->to($uri->to);
    return ($self->{"target"} = $target->canonical);
}

# is_abs: If a given URI is absolute
#   This is a static method.
#   There is no relative mailto URI.
sub is_abs : method { 1; }


__END__

=head1 NAME

chklinks - A non-threaded Perl link checker

=head1 SYNOPSIS

   chklinks [options] URL1 [URL2 [UR3 ...]]

=head1 DESCRIPTION

F<chklinks> is a Perl link checker.  It helps finding broken links
on your website.

F<chklinks> differs from C<linkchecker> in that F<chklinks> is non-
threaded.  It does not raises many simultaneously connections for its
job.  It won't run out of the resources and crash your system in a
moment.  This is certainly more desirable for most webmasters and
users.

F<chklinks> follows F<robots.txt> rules.  If you disallow robots
from your website and experience problems, you need to allow
F<chklinks>.  Add the following lines to your F<robots.txt> file to
allow F<chklinks>:

  User-agent: chklinks
  Disallow:

F<chklinks> uses L<LWP::RobotUA(3)|LWP::RobotUA/3> and support the
following schemes: http, https, ftp, gopher and file.  You can also
specify a local file.  (To use https, you need to install
L<Crypt::SSLeay(3)|Crypt::SSLeay/3>.  This is the requirement of
L<LWP::RobotUA(3)|LWP::RobotUA/3>.)

F<chklinks> supports cookies.

=head1 OPTIONS

=over

=item -1,--onelevel

Check the links on this page and stops.

=item -r,--recursive

Recursively check through this website.  This is the default.

=item -b,--below

Only check the links below this directory.  This is the default.

=item -p,--parent

Trace back to the parent directories.

=item -l,--local

Only check the links on this same host.

=item -s,--span

Check the links to other hosts (without recursion).  This is the
default.

=item -e,--exclude path

Exclude this path.  Check for their existence but not check the links
on them, just like they are on a foreign site.  Multiple C<--exclude>
are OK.

=item -i,--include path

Include this path.  An opposite of C<--exclude> that cancels its
effect.  The latter specified has a higher priority.

=item -d,--debug

Display debug messages.  Multiple C<--debug> to debug more.

=item -q,--quiet

Disable debug messages.  An opposite that cancels the effect of
C<--debug>.

=item -h,--help

Display the help message and exit.

=item -v,--version

Output version information and exit.

=item URL1, URL2, URL3

The URLs of the websites to check against.

=back

=head1 NOTES

F<chklinks> does not obey C<Crawl-delay:> in F<robots.txt> yet.
This is a problem in L<WWW::RobotRules(3)|WWW::RobotRules/3>, but
not F<chklinks> itself.

If you encounter warnings like this:

    Parsing of undecoded UTF-8 will give garbage when decoding
    entities at /usr/share/perl5/LWP/Protocol.pm line 114.

This is a L<LWP::Protocol(3)|LWP::Protocol/3> issue when working
with L<HTML::Parser(3)|HTML::Parser/3> version >= 3.40.
See CPAN RT Bug#20274 http://rt.cpan.org/Public/Bug/Display.html?id=20274
for a L<LWP::Protocol(3)|LWP::Protocol/3> patch on this.

=head1 BUGS

F<chklinks> does not support authentication yet.  W3C-LinkChecker
have support on this.  As a workaround, You can use the syntax
http://user:pass@some.where.com/some/path for Basic Authentication,
but this does not work on Digest Authentication.  This practice is
not encouraged.  Your password would be visable to anyone on this
system using F<ps>, including hidden intruders.  Also what you type
in your shell will be saved to your shell history file.

C<mailto:> URLs should be supported by checking the validity of its
DNS/MX record.  Bastian Kleineidam's L<linkchecker(1)|linkchecker/1>
have support on this.

Local file checking has only been tested on Unix and MSWin32.  More
platforms should be tested, especially VMS and Mac.

=head1 SUPPORT

F<chklinks> is hosted on SourceForge, CPAN and Tavern IMACAT's.  For
the latest infomation, see http://chklinks.sourceforge.net/ ,
http://sourceforge.net/projects/chklinks/ ,
http://search.cpan.org/dist/chklinks/ or
http://www.imacat.idv.tw/tech/chklinks.html .

F<chklinks> has a user discussion mailing list hosted at
SourceForge: chklinks-users@lists.sourceforge.net .  It is a mailman
mailing list.  For infomation on how to join or leave, see:
http://lists.sourceforge.net/lists/listinfo/chklinks-users .
Alternatively, you can send a mail to:
chklinks-users-request@lists.sourceforge.net with the subject C<help>
for a list of available commands.

=head1 SEE ALSO

L<LWP::UserAgent(3)|LWP::UserAgent/3>,
L<LWP::RobotUA(3)|LWP::RobotUA/3>, L<WWW::RobotRules(3)|WWW::RobotRules/3>,
L<URI(3)|URI/3>, L<HTML::LinkExtor(3)|HTML::LinkExtor/3>,
Bastian Kleineidam's L<linkchecker(1)|linkchecker/1>,
W3C-LinkChecker L<checklink(1)|checklink/1>.

=head1 AUTHOR

imacat <imacat@mail.imacat.idv.tw>.

=head1 COPYRIGHT

Copyright (c) 2003-2007 imacat.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but I<WITHOUT ANY WARRANTY>; without even the implied warranty of
I<MERCHANTABILITY> or I<FITNESS FOR A PARTICULAR PURPOSE>.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see L<http://www.gnu.org/licenses/>.

=cut
